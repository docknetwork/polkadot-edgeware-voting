{"version":3,"file":"static/webpack/static/development/pages/index.js.9f8a6f181ad375dfa470.hot-update.js","sources":["webpack:///./services/substrate.js"],"sourcesContent":["import {ApiPromise, WsProvider} from '@polkadot/api';\nimport {Keyring} from '@polkadot/api';\nimport {Observable} from 'rxjs';\n\nimport {IdentityTypes} from 'edgeware-node-types/dist/identity';\nimport {VotingTypes} from 'edgeware-node-types/dist/voting';\nimport {SignalingTypes} from 'edgeware-node-types/dist/signaling';\nimport {\n  Balance2,\n  TreasuryRewardTypes,\n} from 'edgeware-node-types/dist/treasuryReward';\n\nexport const nodeAddress = 'ws://127.0.0.1:9944';\n\nclass SubstrateService {\n  constructor() {\n    this.state = {};\n    this.onConnectCallbacks = [];\n    this.onUpdateState = new Observable(observer => {\n      this.onUpdateStateObserver = observer;\n    });\n  }\n\n  async connect() {\n    if (this.state.connected) {\n      return;\n    } else if (this.state.connecting) {\n      console.log('still connecting, adding callback');\n      return new Promise(resolve => {\n        this.onConnectCallbacks.push(resolve);\n      });\n    }\n\n    this.state.connecting = true;\n\n    // Initialise the provider to connect to the local node\n    const provider = new WsProvider(nodeAddress);\n    const keyring = new Keyring({type: 'sr25519'});\n    this.keyring = keyring;\n\n    // Create the API and wait until ready\n    this.api = await ApiPromise.create({\n      provider,\n      types: {\n        ...IdentityTypes,\n        ...VotingTypes,\n        ...SignalingTypes,\n        ...TreasuryRewardTypes,\n        ...Balance2,\n      },\n    });\n\n    // Retrieve the chain & node information information via rpc calls\n    const [chain, nodeName, nodeVersion] = await Promise.all([\n      this.api.rpc.system.chain(),\n      this.api.rpc.system.name(),\n      this.api.rpc.system.version(),\n    ]);\n\n    this.state.connected = true;\n    this.state.connecting = false;\n\n    // loop on connect callbacks\n    for (let i = 0; i < this.onConnectCallbacks.length; i++) {\n      const callback = this.onConnectCallbacks[i];\n      callback();\n    }\n    this.onConnectCallbacks = [];\n\n    return this.setState({\n      ...this.state,\n      chain,\n      nodeName,\n      nodeVersion,\n    });\n  }\n\n  async getVoteRecords(index) {\n    if (!this.state.connected) {\n      return this.connect().then(() => this.getVoteRecords(index));\n    }\n\n    return this.api.query.voting.voteRecords(index);\n  }\n\n  async getProposal(hash) {\n    if (!hash) {\n      return;\n    }\n\n    if (!this.state.connected) {\n      return this.connect().then(() => this.getProposal(hash));\n    }\n\n    return this.api.query.signaling.proposalOf(hash);\n  }\n\n  async getActiveProposals(callback) {\n    if (!this.state.connected) {\n      return this.connect().then(() => this.getActiveProposals(callback));\n    }\n\n    this.api.query.signaling.activeProposals(proposals => {\n      callback(this.formatProposalList(proposals.toArray()));\n    });\n  }\n\n  async getCompletedProposals(callback) {\n    if (!this.state.connected) {\n      return this.connect().then(() => this.getCompletedProposals(callback));\n    }\n\n    this.api.query.signaling.completedProposals(proposals => {\n      callback(this.formatProposalList(proposals.toArray()));\n    });\n  }\n\n  async getInactiveProposals(callback) {\n    if (!this.state.connected) {\n      return this.connect().then(() => this.getInactiveProposals(callback));\n    }\n\n    this.api.query.signaling.inactiveProposals(proposals => {\n      callback(this.formatProposalList(proposals.toArray()));\n    });\n  }\n\n  async advanceProposal(hash, onComplete, onError) {\n    if (!this.state.connected) {\n      return this.connect().then(() => this.advanceProposal(hash));\n    }\n\n    return this.signAndSend(\n      this.api.tx.signaling.advanceProposal(hash),\n      onComplete,\n      onError\n    );\n  }\n\n  async createProposal(\n    {title, contents, outcomes, voteType, tallyType},\n    onComplete,\n    onError\n  ) {\n    if (!this.state.connected) {\n      return this.connect().then(() =>\n        this.createProposal(title, contents, outcomes, voteType, tallyType)\n      );\n    }\n\n    return this.signAndSend(\n      this.api.tx.signaling.createProposal(\n        title,\n        contents,\n        outcomes,\n        voteType,\n        tallyType\n      ),\n      onComplete,\n      onError\n    );\n  }\n\n  async vote(id, outcome, isCommitReveal, onComplete, onError) {\n    const resultOutcome = new Uint8Array(\n      outcome\n        .substr(2, outcome.length)\n        .match(/.{1,2}/g)\n        .map(byte => parseInt(byte, 16))\n    );\n    if (isCommitReveal) {\n      // not supported properly yet\n      return this.signAndSend(\n        this.api.tx.voting.commit(id, resultOutcome),\n        onComplete,\n        onError\n      );\n    } else {\n      // general purpose vote\n      const options = [resultOutcome]; // TODO: support multiple options\n      return this.signAndSend(\n        this.api.tx.voting.reveal(id, options, null),\n        onComplete,\n        onError\n      );\n    }\n  }\n\n  async signAndSend(transfer, onComplete, onError) {\n    const unsub = await transfer\n      .signAndSend(this.getAccount(), ({events = [], status}) => {\n        console.log(`Current status is ${status.type}`, status);\n\n        if (status.isFinalized) {\n          console.log(\n            `Transaction included at blockHash ${status.asFinalized}`\n          );\n\n          // Loop through Vec<EventRecord> to display all events\n          events.forEach(({phase, event: {data, method, section}}) => {\n            console.log(`\\t' ${phase}: ${section}.${method}:: ${data}`);\n          });\n\n          if (onComplete) {\n            onComplete(status, events);\n          }\n          unsub();\n        }\n      })\n      .catch(error => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  }\n\n  formatProposalList(proposals) {\n    const result = [];\n    proposals.forEach(proposal => {\n      const baseData = proposal.toJSON();\n      const proposalData = {\n        hash: baseData[0],\n      };\n\n      this.getProposal(baseData[0]).then(data => {\n        proposalData.data = data.toJSON();\n      });\n\n      result.push(proposalData);\n    });\n    return result;\n  }\n\n  getAccounts() {\n    if (this.keyring && this.state && this.state.connected) {\n      const alice = this.keyring.addFromUri('//Alice', {name: 'Alice'}); // dev only, of course\n      return this.keyring.getPairs();\n    } else {\n      return [];\n    }\n  }\n\n  setAccount(account) {\n    this.account = account;\n  }\n\n  getAccount() {\n    if (this.account) {\n      return this.account;\n    }\n\n    if (this.keyring) {\n      // TODO: allow to set custom accounts\n      const accounts = this.getAccounts();\n      if (accounts.length) {\n        return accounts[0];\n      }\n    }\n  }\n\n  connected() {\n    return this.state.connected;\n  }\n\n  setState(value) {\n    this.state = value;\n    this.onUpdateStateObserver.next(value);\n    return value;\n  }\n}\n\nexport default new SubstrateService();\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA;;;;;;;;AAEA;;;;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AACA;;AADA;;AAYA;AACA;;;;AADA;AAAA;AAAA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAJA;AACA;;;;;;;;;;AAOA;;;;;;;AACA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;;;;;;;;AAEA;;;;;;;AACA;;;;;;;;AAIA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;;;;;;;;AAEA;;;;;;;AACA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;;AACA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;;AACA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;;AACA;;;;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;;;;;;;;AAQA;;;;;;;;AADA;AACA;AAGA;;;;;AACA;AAAA;AAAA;AACA;;AAIA;AACA;;;;;;;;;;AAYA;;;;;;AACA;AAIA;AAAA;AACA;AACA;;;;;AAEA;AACA;;AAKA;AACA;AACA;AAAA;AACA;;;;;;;;;;AAOA;;;;;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAzBA;AACA;;;;;;;;;;AA0BA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;A","sourceRoot":""}